\documentclass[a4paper,11pt]{article}


\usepackage{geometry}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{tikz-uml}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{listings}
\usepackage{float}

\lstset{
language=C++,
basicstyle=\footnotesize,
backgroundcolor=\color{white},
keywordstyle=\color{red},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve}, 
numberstyle=\color{red},
morekeywords={string},
frame=BL,
aboveskip=1em,
belowskip=2em,
}
\lstset{
  literate={ù}{{\`u}}1
           {é}{{\'e}}1
           {è}{{\'e}}1
           {à}{{\`a}}1
}


\lstdefinelanguage{tikzuml}{language=[LaTeX]TeX, classoffset=0, morekeywords={umlbasiccomponent, umlprovidedinterface, umlrequiredinterface, umldelegateconnector, umlassemblyconnector, umlVHVassemblyconnector, umlHVHassemblyconnector, umlnote, umlusecase, umlactor, umlinherit, umlassoc, umlVHextend, umlinclude, umlstateinitial, umlbasicstate, umltrans, umlstatefinal, umlVHtrans, umlHVtrans, umldatabase, umlmulti, umlobject, umlfpart, umlcreatecall, umlclass, umlvirt, umlunicompo, umlimport, umlaggreg}, classoffset=1, morekeywords={umlcomponent, umlsystem, umlstate, umlseqdiag, umlcall, umlcallself, umlfragment, umlpackage}, classoffset=0,  sensitive=true, morecomment=[l]{\%}}

\geometry{margin=2cm}
\geometry{headheight=15pt}

\usepackage{fancyhdr}
\usepackage{fancyvrb} 
\usepackage{graphicx}
\usepackage{float}

\pagestyle{fancy}
\rhead{PFA - GuitarTutor}


\begin{document}

\begin{titlepage}
  \begin{center}

    \textsc{\LARGE PFA - GuitarTutor}\\[2cm]
    Pacien \textsc{Boisson} \ \ \ Jean-Michaël \textsc{Célerier}  \ \ \ Julien \textsc{Chaumont}\\
    Abdelhamid \textsc{Cherif} \ \ \ Alban \textsc{De Martin} \ \ \ Kun \textsc{Jiao} \ \ \ Bastien \textsc{Meunier} \\[3cm]
    \textsc{\large 29/03/2013 }\\[1.5cm]
    \includegraphics[width=8cm]{logo.png}

  \end{center}
  \vspace{3cm}
  \begin{flushleft}
   \underline{Clients :} Pierre \textsc{Hanna}, Matthias \textsc{Robine}\\
   \underline{Responsable pédagogique :} Julien \textsc{Allali}
  \end{flushleft}


\end{titlepage}

\clearpage

\section*{Introduction}
%Dans cette partie, j'ai repris quasiment mot pour mot l'intro que j'avais écrite pour le cahier des charges.

\subsection*{Serious game}

En quelques années, les jeux vidéos ont su attirer un public immense et éclectique. Alors qu'ils étaient réservés, il y a encore quelques années, à un public bien ciblé, les éditeurs ont su s'ouvrir à toute une gamme de joueurs jusqu'alors insoupçonnés - l'appellation casual gamer était née. Aujourd'hui, les recherches dans le domaine vidéo-ludique vont encore plus loin. A l'aide de technologies toujours plus poussées, toujours plus proches du joueur et de son environnement, il est désormais possible d'interagir avec lui, grâce à ses mouvements par exemple. Et pourquoi pas par le son? Les jeux de rythme, remontant pourtant aux bornes d'arcade des années 1990, ont connu un immense succès avec la sortie de jeux tels que Guitar Hero en 2005, qui a ouvert la voie à de nombreux remakes que sont Just Dance ou encore Band Hero. En parallèle, les jeux à caractère éducatifs, ont été pendant longtemps recalés au rang de “sous-jeux” de par leurs gameplays souvent repoussants et des graphismes généralement peu soignés - 
évidemment, les budgets ne sont pas forcément les mêmes.

Le projet GuitarTutor se place au croisement de ces deux genres pour s'inscrire dans celui très fermé des serious games: pourquoi ne pas apprendre en s'amusant? (En l'occurrence l'apprentissage de la guitare). Ce jeu s'adresse à des élèves d'écoles de musique débutant la pratique de l'instrument. L'objectif est de les encourager à jouer et à s'entraîner en dehors des heures de cours avec leurs professeurs, en faisant intervenir cet univers ludique, pour les inciter à persévérer et à travailler d'eux-mêmes.

\subsection*{Le logiciel avant le PFA}

Le logiciel GuitarTutor reposait sur des travaux de recherches du LABRI, ainsi que sur le travail fourni par des élèves de l'ENSEIRB-MATMECA dans le cadre des Projets au Fil de l'Année (PFA) de 2011-2012. La base du projet consistait en l'analyse d'accords en temps réel, c'est-à-dire pouvoir donner précisément le nom de l'accord qui est donné en entrée audio de l'ordinateur. La librairie EHPCP a donc été codée à cet effet. En complément, le développement d'une interface graphique, à l'aide de la librairie Qt, a été réalisée. Celle-ci assurait le fonctionnement basique d'un logiciel permettant de visualiser une liste défilante d'accords ainsi que le résultat de la partie analyse de l'entrée audio, en comparant cette donnée au résultat attendu.

Afin de faciliter l'écriture de ces fichiers partitions, un second logiciel avait été mis en place à destination du professeur. Il permettait une édition totalement manuelle de grilles d'accords, ainsi qu'une édition assistée. Ce second mode d'édition demandait à l'utilisateur de marquer les accords d'un morceau joué simultanément par l'appui sur une touche de son clavier. Dans un deuxième temps, il suffisait d'indiquer quels étaient les accords qui correspondaient à chaque pulsation.

\subsection*{Notre objectif}

L'objectif de notre projet était donc de rendre le logiciel existant accessible. Son interface d'origine avait, en effet, plus la carrure d'un prototype que celle d'un produit fini. Un soin particulier devait être apporté à l'éditeur de partitions afin d'optimiser au mieux l'expérience utilisateur. Selon les demandes clients, GuitarTutor devait être un logiciel fini et livrable pour avril 2013.

\clearpage

\tableofcontents

\clearpage

\section{Architecture logicielle}

Nous présenterons dans cette partie la structure du projet actuel, ainsi que celle de sa version d'origine.

\subsection{Architecture du projet d'origine}

\subsection{Le modèle MVC}

Le modèle MVC, pour \textit{Modèle, Vue, Contrôleur}, constitue une architecture logicielle particulière qui se base sur la différenciation de deux parties dans un programme:
\begin{itemize}
 \item Les données (le modèle)
 \item L'interface graphique (la vue)
\end{itemize}

Le contrôleur se place entre ces deux entités, en agissant comme relais en synchronisant les informations qui transitent de l'une à l'autre.

L'avantage immédiat du modèle MVC est l'organisation du code qu'il induit, ainsi que la facilitation de la maintenance de celui-ci.

\subsection{Editeur, Lecteur et API}

Il nous a été conseillé dès le début du projet d'adopter le modèle MVC. En plus des avantages cités précédemment, cela nous permettait de découvrir le code existant, de mieux le comprendre, et de commencer à le réorganiser correctement. L'architecture qui a été retenue était de découper le projet en trois parties:
\begin{itemize}
 \item L'interface graphique du lecteur
 \item L'interface graphique de l'éditeur
 \item Le reste: l'API
\end{itemize}
L'idée était de mettre ce \textit{reste} dans une bibliothèque qui serait appelée à la fois par l'éditeur et par le lecteur (même si ce ne sont pas forcément les mêmes parties qui les intéressent). La figure \ref{mvc} résume cette organisation.

\begin{figure}[H]
\begin{center}
\includegraphics[width=300px]{mvc.png}
\caption{Le modèle MVC dans notre code}
\label{mvc}
\end{center}
\end{figure}

\subsubsection{L'API}

L'API a été mise en place dès le début du projet, en regroupant dans un même dossier tous les fichiers sources qui ne concernaient pas dirctement l'interface graphique du lecteur, ni celle de l'éditeur.

\subsubsection*{La modélisation des accords}

Nous avons ensuite ajouté de nouvelles classes pour modéliser les accords de manière la plus abstraite possible, afin de respecter au mieux les objets Modèle du MVC. Nous avons pour cela utilisé trois classes (Tonality, Enrichment, Chord), ainsi que deux énumérations (Note et Alteration) pour définir un accord selon le schéma suivant:
\begin{itemize}
 \item Une \textcolor{blue}{tonalité}, c'est une \textcolor{red}{note} et une \textcolor{green}{altération}: \textcolor{red}{A}\textcolor{green}{$\sharp$}, \textcolor{red}{C}\textcolor{green}{$\flat$}, \textcolor{red}{G}\textcolor{green}{$\natural$}, \dots
 \item Un accord, c'est une \textcolor{blue}{tonalité} et un \textcolor{magenta}{mode}: \textcolor{blue}{G$\flat$}\textcolor{magenta}{m}, \textcolor{blue}{B$\sharp$}\textcolor{magenta}{M}, \dots
\end{itemize}

Cette découpe des modèles se répercute dans l'architecture de ces classes (voir le diagramme de classes de la figure \ref{diag_api_chords}). Bien sûr, différentes méthodes ont été implémentées pour ces différentes classes, bien qu'en réalité peu d'entre elles soient réellement utilisées par GuitarTutor. C'était néanmoins un bon moyen de repartir sur de bonnes bases au début du projet, et certaines de ces méthodes nous ont finalement été utiles plus tard dans la phase de développement. C'est pourquoi nous avons décidé de les laisser dans l'API, dans le cas probable qu'elles soient utiles plus tard à GuitarTutor.

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}
\umlclass[x=-7, y=0]{Chord}{
}{}
\umlclass[x=-13, y=-3]{Enrichment}{
}{}
\umlclass[x=-1, y=-3]{Tonality}{
}{}
\umlclass[x=-1, y=-6]{Note}{
}{}
\umlclass[x=-7, y=-6]{Alteration}{
}{}

\umlunicompo[]{Chord}{Enrichment}
\umlunicompo[]{Chord}{Tonality}
\umlunicompo[]{Tonality}{Alteration}
\umlunicompo[]{Tonality}{Note}
\end{tikzpicture}
\caption{La modélisation des accords dans l'API}
\label{diag_api_chords}
\end{center}
\end{figure}

\subsubsection*{La classe \textit{LogicalTrack} et les classes associées}

Ultérieurement, c'est la classe \textit{LogicalTrack} que nous avons mise en place. Cet objet représente en mémoire une grille d'accords. Elle est utilisée par l'éditeur, qui transforme les données entrées par l'utiliseur en une instance de \textit{LogicalTrack}, puis fais la conversion en un fichier XML; et de l'autre côté, elle est utilisée par le lecteur qui initialise un objet \textit{LogicalTrack} à partir de la lecture d'un fichier XML. Sa structure est relativement simple et correspond parfaitement à celle que nous avons choisi d'adopter pour les fichiers XML de sauvegarde de grilles (le format est expliqué plus en détail dans la partie \ref{xml}):
\begin{itemize}
 \item Une grille est une suite de parties (intro, refrain, couplet 1,\dots).
 \item Chaque partie est composée d'une suite de notes
 \item A chaque note correspond un temps de début, le temps de fin étant le début de la note suivante
\end{itemize}

Là encore, le découpage des classes découle parfaitement de cette vision d'une grille (figure \ref{diag_api_tracks}). Parallèlement, la classe \textit{TrackLoader}, elle aussi dans l'API, contient deux méthodes statiques qui permettent la conversion d'une instance de \textit{LogicalTrack} vers un fichier XML, ou inversement.

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}
\umlclass[x=-13, y=0]{LogicalTrack}{
}{}
\umlclass[x=-7, y=0]{PartTrack}{
}{}
\umlclass[x=-1, y=0]{TrackChord}{
}{}

\umlunicompo[]{LogicalTrack}{PartTrack}
\umlunicompo[]{PartTrack}{TrackChord}
\end{tikzpicture}
\caption{Modélisation d'une grille d'accords dans l'API}
\label{diag_api_tracks}
\end{center}
\end{figure}

\subsubsection*{Les autres rôles de l'API}

Comme évoqué en introduction de cette partie, l'API a été à la base construit sur les parties du code d'origine n'étant pas directement liées à l'interface. C'est en suivant ce principe que nous avons ajouté à l'API la bibliothèque IScoreLight, qui servait à la lecture de grilles d'accord, ainsi que EHPCP qui est utilisée pour la reconnaissance des accords. Dans la même veine, on peut évoquer les classes qui servaient déjà à la gestion audio du lecteur, telles que \textit{Track} (que nous avons plus tard adaptée à nos besoins) pour charger en mémoire un fichier audio, ou \textit{MusicManager}, classe pilier concernant la gestion des entrées et des sorties audio.

\subsubsection{L'éditeur}

Le rôle de l'éditeur est d'assister l'utilisateur pour construire une grille d'accords qui soit lisible et jouable sur le lecteur. En accord avec la conception MVC, l'éditeur en lui-même ne regroupe que les éléments se rapportant à l'interface graphique ou ayant des rôles de contrôleurs. La souche de l'éditeur est en fait le widget \textit{GridEditor}, qui sert à la fois d'interface et d'orchestrateur entre les différentes sous-composantes de l'éditeur, à savoir:
\begin{itemize}
 \item \textit{ChordTableWidget}, qui apparaît à l'écran comme un tableau où chaque case (instances de la classe \textit{CaseItem}) doivent contenir un accord
 \item \textit{AudioWindow}, qui regroupe tout ce qui a trait à la synchronisation entre les accords de la grille et le morceau qui sera joué simultanément dans le lecteur.
 \item \textit{TrackProperties}, qui sert à concentrer toutes les informations générales sur la grille en cours d'édition, telles que le nom de l'artiste, la signature rythmique, etc.
\end{itemize}

La classe \textit{GridEditor} orchestre donc l'ensemble des actions de l'utilisateur sur chacune de ces sous-composantes en répercutant les effets sur les autres composantes. Par exemple, changer le nombre d'accords par mesure dans \textit{TrackProperties} va changer l'affichage du \textit{ChordTableWidget}; ou encore, changer le tempo dans l'objet \textit{AudioWindow} va décaler les temps de chaque \textit{CaseItem}.


\begin{figure}[H]
\begin{center}
\begin{tikzpicture}
\umlclass[x=-7, y=0]{GridEditor}{
}{}
\umlclass[x=-13, y=-3]{ChordTableWidget}{
}{}
\umlclass[x=-5, y=-3]{AudioWindow}{
}{}
\umlclass[x=-1, y=0]{TrackProperties}{
}{}
\umlclass[x=-13, y=-6]{CaseItem}{
}{}
\umlclass[x=-10,y=-6]{AudioSync}{
}{}
\umlclass[x=-5,y=-6]{SimpleMusicPlayer}{
}{}
\umlclass[x=0,y=-6]{Waveform}{
}{}

\umlunicompo[]{GridEditor}{ChordTableWidget}
\umlunicompo[]{GridEditor}{AudioWindow}
\umlunicompo[]{GridEditor}{TrackProperties}
\umlunicompo[]{ChordTableWidget}{CaseItem}
\umlunicompo[]{AudioWindow}{AudioSync}
\umlunicompo[]{AudioWindow}{SimpleMusicPlayer}
\umlunicompo[]{AudioWindow}{Waveform}
\end{tikzpicture}
\caption{Diagramme de classes synthétique de l'éditeur}
\label{diag_editor}
\end{center}
\end{figure}

\subsubsection{Le lecteur}

\begin{figure}[H]
\begin{center}
\begin{tikzpicture}
\umlclass[x=-7, y=0]{Controler}{
m\_track : LogicalTrack *}{}
\umlclass[x=-13, y=-3]{PlayerScene}{
}{}
\umlclass[x=-1, y=-3]{SongManager}{
}{}
\umlclass[x=-1, y=0]{Configuration}{
}{}
\umlclass[x=-13, y=-6]{ScrollingItem}{
}{}
\umlclass[x=-9,y=-6]{EntireSong}{
}{}
\umlclass[x=-1,y=-6]{MusicManager}{
}{}

\umlunicompo[]{Controler}{PlayerScene}
\umlunicompo[]{Controler}{SongManager}
\umlunicompo[]{Controler}{Configuration}
\umlunicompo[]{PlayerScene}{EntireSong}
\umlunicompo[]{PlayerScene}{ScrollingItem}
\umlunicompo[]{SongManager}{MusicManager}
\end{tikzpicture}
\caption{Diagramme de classes synthétique du lecteur}
\label{diag_player}
\end{center}
\end{figure}

\subsection{Quelques points particuliers}

\clearpage




\section{Problèmes rencontrés, problèmes résolus}

Le développement de GuitarTutor ne s'est pas fait sans heurts. Nous sommes néanmoins parvenus à résoudre les différents problèmes auxquels nous avons été confrontés au cours des phases de développement.

\subsection{Reprise de code}

Comme c'était prévu, la reprise du code existant fut notre première grande étape de développement. Passé le moment de découragement lié à l'absence total de commentaires et de documentation dans la grande majorité du code source qui nous intéressait, nous nous sommes attelés à ``débroussailler'' le dépôt en mettant en place une documentation, en commentant le code, ainsi qu'en supprimant purement et simplement les portions inutilisées, qui représentaient tout de même une portion loin d'être négligeable (parfois de simples fonctions, parfois des fichiers, et parfois des dossiers entiers\dots).

Par ailleurs, du fait que le projet ait été constitué de plusieurs blocs de code émanant de différentes équipes de développeurs, nous avons pu remarquer que les conventions de codage n'avaient pas été harmonisées. Nous avons pris soin de réparer cette erreur afin de faciliter la relecture et donc la réutilisation de ce même code.

Passés ces quelques semaines de nettoyage et d'assimilation du code existant, nous avons pu commencer à apporter les modifications établies dans le cahier des charges, bien que, tout au long du développement, nous ayons continué la refactorisation (par exemple les suppressions de certaines bibliothèques, évoquées plus loin dans ce rapport).

\subsection{Refonte de l'interface du lecteur}

Le refonte totale de l'interface du lecteur s'est présenté comme un véritable challenge. Il s'agissait en effet de supprimer tout ce qui concernait l'interface dans le projet existant, et d'y mettre à la place notre propre code. Évidemment, il n'était pas question de se limiter à une structure identique à l'interface existante, celle-ci étant véritablement limitée en terme de fonctionnalités, et m\^eme carrément repoussante pour un jeune guitariste débutant. Fort heureusement, le lecteur était déjà plut\^ot bien décomposé selon le modèle MVC, ce qui nous a tout de m\^eme motivé à tenter l'expérience.

La nouvelle interface a donc été développée seule, totalement séparée du reste du projet, en utilisant des faussaires pour simuler une grille d'accords, et selon une maquette que nous avions soumise à nos clients (voir figure \ref{annexe_proto_player} en annexe). Ce n'est qu'au bout de plusieurs semaines de développement que nous avons enfin pu intégrer la nouvelle interface au reste du projet. Cette intégration ne s'est pas faite sans heurts, mais a finalement aboutie, comme nous l'espérions (voir figure \ref{interface_player}).

\begin{figure}[H]
\begin{center}
\includegraphics[width=175px]{ancien_player.png}
\includegraphics[width=275px]{interface_player.png}
\caption{L'interface du lecteur a été entièrement refaite}
\label{interface_player}
\end{center}
\end{figure}

\subsection{Portabilité}

La portabilité du logiciel, notamment sur Mac OS et Windows, faisait partie des principales demandes des clients. Les librairies utilisées jusque là était censées fonctionner à la fois sur Mac OS, Windows et GNU/Linux, et c'était une bonne raison pour ne pas en changer.

Nous nous sommes cependant rapidement rendus à l'évidence: on ne développe pas un logiciel portable simplement en utilisant des librairies portables.

\subsubsection*{Sur Mac OS}

Personne, dans notre équipe, n'ayant une machine sous Mac OS, nous avons dû nous contenter d'une version de Mountain Lion en machine virtuelle. Outre un problème d'extrême lenteur lors de la compilation et divers autres soucis liés à la connexion internet et la reconnaissance des ports USB, il était impossible de vérifier le bon fonctionnement du lecteur, puisque l'entrée audio de la VM n'était pas activée. Nous avons donc pendant longtemps développé \textit{``à l'aveugle''} sous Mac OS, où tout ce que nous pouvions faire était de vérifier que la compilation se faisait correctement.

Fort heureusement, un test sur une vraie machine Mac début mars nous a confirmé que le projet était bien compatible, et nous en avons également profité pour vérifier le fonctionnement de notre installateur.

\subsubsection*{Sur Windows}

%Qt5, l'installateur, boost,...

\subsubsection*{Sur GNU/Linux}

Il s'agit du seul des trois systèmes d'exploitation pour lequel nous n'avons pas eu de problème particulier, mais aussi le seul qui n'était pas demandé. Peut-être est-ce simplement parce que nous avons tous commencé à coder directement sur celui-ci.

\clearpage

\section{Discussion sur les choix opérés}

Du début jusqu'à la fin du projet, nous avons dû faire des choix de conduite. Nous recenserons dans cette partie les principales questions que nous nous sommes posées sur la marche à suivre.

\subsection{Environnement logiciel}

Comme il nous avait été conseillé de faire, nous nous sommes rapidement accordés sur l'environnement logiciel a adopter.
\begin{itemize}
 \item Utilisation de QtCreator, environnement de développement C++ open-source, multi-OS, et régulièrement mis à jour
 \item Développement sur Linux. Le choix n'était pas évident, étant donné que cet OS n'était pas censé devoir être ciblé. L'intérêt était en fait de ne pas favoriser le développement sur Windows, avant de nous rendre compte que certains de nos choix avaient été faits au détriment de Mac OS, ou inversement.
 \item Utilisation du gestionnaire de version Git, et non de SVN. La raison est que Git est de plus en plus utilisé, au détriment de SVN, et que le PFA était une excellente occasion pour apprendre à l'utiliser.
 \item Création du dépôt sur GitHub. Nous avons éliminé le dépôt de l'ENSEIRB-MATMECA en raison d'une coupure qui aura duré plusieurs jours en octobre (en plus des fréquentes interruptions de ce service dont nous avions pris l'habitude au cours de l'année passée), ainsi que de nombreux autres services tels que Sourceforge ou Google Code, car ceux-ci imposaient l'utilisation d'une licence libre (ce qui, a priori, n'est pas le cas de GuitarTutor) aux projets hébergés sur leur plate-forme, à moins de payer un abonnement mensuel. GitHub était également dans ce cas, mais une offre réservée aux étudiants nous a permis de bénéficier gratuitement d'un compte premium pour créer librement un dépôt privé, sans contrainte de licence.
\end{itemize}

Les différents choix énumérés ci-dessus ont été faits au début du projet en analysant les opinions de chacun, puis \textit{``officialisées''} en les listant sur notre wiki.


\subsection{Utilisation de Qt}

Le choix d'utiliser la librairie Qt s'est fait très rapidement, tant les avantages étaient évidents:
\begin{itemize}
 \item Le code source existant utilisait déjà Qt
 \item Qt est utilisable aussi bien sur Mac OS que sur Windows, ainsi que sur Linux
 \item Le développement avec Qt est facilité par l'IDE que nous avions choisi, à savoir QtCreator
 \item La documentation est très claire et complète
 \item Qt est open-source et bénéficie d'une large communauté d'utilisateurs
 \item Qt est incroyablement complet: interface graphique, XML, multimédia, socket,\dots
 \item Plusieurs d'entre nous avions déjà des connaissances sur cette librairie
\end{itemize}

Nous avons donc choisi d'adopter cette librairie dès les débuts du projet.

\subsection{Utilisation de FMOD}

FMOD est la librairie audio qui est utilisée aujourd'hui dans l'éditeur et dans le lecteur. Là encore, c'était cette même librairie qui servait déjà dans l'ancienne version de l'éditeur, dans la partie qui traitait les fichiers audio. En revanche, dans le lecteur, nous avons substitué la librairie \textit{libsndfile} pour FMOD.

FMOD comporte de nombreux avantages, comme par exemple la lecture de formats compressés tels que le mp3, aujourd'hui incontournable. Jusqu'à présent, \textit{libsndfile} limitait l'utilisation de GuitarTutor aux fichiers wav, ce qui contraignait l'utilisateur à manipuler des fichiers de très grande taille dans des formats dépassés. FMOD disposait également des mêmes fonctionnalités que celles qui étaient alors utilisées dans le code avec \textit{libsndfile}, ce qui permettait de ne pas géner la transition. FMOD nous a donc semblé être un bon choix, malgré le fait qu'il s'agisse d'un code propriétaire (nous n'avons pas eu de contre-indication de la part des clients à ce propos).

\subsection{Format d'échange en XML}
\label{xml}

L'échange entre l'éditeur et le lecteur se fait par l'intermédiaire de fichiers. Ces fichiers sont créés et modifiés par l'éditeur, puis lus dans le lecteur. Initialement, le format qui était utilisé listait les différentes parties du morceau, ainsi que les accords devant être joués et le temps en millisecondes correspondant (par rapport au début de la musique). Le fichier audio lu simultanément était, quant à lui, codé en dur dans le code source. Bien qu'il eut été facile de se contenter d'intégrer le chemin du fichier audio en début de fichier, nous avons préféré repenser totalement le format du fichier d'échange en nous basant sur le langage XML.

\begin{table}[H]
\begin{center}
\begin{tabular}{l|l}
 & \verb{<?xml version="1.0"?>{\\
 & \verb{<morceau timeSignature="4" line="16" chordMesure="1" end="261735"{ \\
 & \verb{  nom="Hotel California" comment="Un classique de 1976" column="4"{ \\
 & \verb{  fichier="Tracks/HotelCalifornia/EaglesHotelCalifornia.mp3"{ \\
 & \verb{  beginning="53145" bar="56402" artiste="The Eagles">{ \\
\verb{[COUPLET1]{ & \verb{  <partie nom="Couplet 1">{ \\
\verb{Bm 53145{ & \verb{    <accord nom="Bm" temps="53145" repetition="1"/>{ \\
\verb{F# 56402{ & \verb{    <accord nom="F#" temps="56402" repetition="1"/>{ \\
\verb{...{ & \verb{    ...{\\
 & \verb{  </partie>{\\
 & \verb{</morceau>{\\
\end{tabular}
\caption{Comparaison entre ancien et nouveau formats d'échange}
\label{fichiers_xml}
\end{center}
\end{table}

Comme on peut le voir sur l'exemple du tableau \ref{fichiers_xml}, notre format de fichier nous permet de contenir bien plus d'informations que l'ancien format. C'est un très gros avantage lorsqu'il s'agit notamment de recharger le fichier dans l'éditeur pour le modifier, puisque toutes les données qui ont été entrées lors de la création du fichier y ont été sauvegardées (même si certaines ne sont pas directement utilisées dans le lecteur).

Un second avantage est la facilité d'adaptation du format. En effet, si un jour il est décidé d'ajouter une nouvelle information dans le fichier XML, il n'y aura a priori pas besoin de modifier la façon de récupérer les informations. Cette maléabilité permise par le standard DOM (\textit{Document Object Model}) qui permet de naviguer au sein d'un document XML sans avoir à connaître tout son contenu. C'est justement la technique qui est mise en \oe uvre dans le module QtXML que nous avons utilisé (voir l'exemple de la figure \ref{xml_dom}).

\begin{figure}[H]
\begin{lstlisting}
//Récupération du premier accord de la partie courante
QDomNode chordNode = partElement.firstChild();
while(!chordNode.isNull())
{
  QDomElement chordElement = chordNode.toElement();
  
  //Récupération des informations de l'accord
  QString name = chordElement.attribute("nom", 0);
  int t = (chordElement.attribute("temps", 0)).toInt();
  int rep = (chordElement.attribute("repetition", 0)).toInt();
  
  //Création de l'objet représentant l'accord
  currentChord = new TrackChord(name, t, rep, previousChord, 0, currentPartTrack);
  //Ajout de cet accord à la liste des accords de la partie courante
  currentPartTrack->AddChord(currentChord);

  //Passage à l'accord suivant
  chordNode = chordNode.nextSibling();
}
\end{lstlisting}
\caption{Lecture d'un fichier XML, extrait de \texttt{TrackLoader::convertXmlToLogicalTrack}}
\label{xml_dom}
\end{figure}

\subsection{Reprise des bases précédentes}

Même s'il était au départ tentant de faire table rase et de recommencer le projet à zéro, tant la présentation du code existant laissait à désirer, nous avons fait l'effort de le remanier et de l'appréhender afin de pouvoir le réutiliser au maximum.

\subsubsection{Sur l'éditeur}

Nous avons gardé la base de l'interface de l'éditeur, à savoir le système de grilles, ainsi que le système d'arbre des accords. Nous avons ensuite ajouté peu à peu les différents éléments qui constituent aujourd'hui l'éditeur de grilles (voir figure \ref{av_ap_editeur}).

\begin{figure}[H]
\begin{center}
\includegraphics[width=225px]{ancien_editeur.png}
\includegraphics[width=225px]{nouveau_editeur.png}
\caption{L'éditeur de grilles, avant et après}
\label{av_ap_editeur}
\end{center}
\end{figure}


\subsubsection*{Quelques mots sur l'interface}

Un des points importants qui étaient à prendre en compte lors du développement était le fait qu'il fallait réaliser un logiciel accessible. L'expérience utilisateur était par conséquent un des facteurs clés. Le problème était que la tâche à réaliser demandait un savoir-faire particulier (par exemple, synchroniser un tableau avec un morceau de musique), et il était donc primordial de la rendre le plus accessible possible, sans pour autant limiter les fonctionnalités.

Nous avons fait le choix de penser en premier lieu à l'expérience utilisateur, en créant une interface qui soit à la fois accessible et esthétique. Nous avons par exemple apporté:
\begin{itemize}
 \item la traduction en Français de l'interface
 \item la possibilité d'ajouter les accords au clavier, comme il serait tentant de faire
 \item une meilleure visibilité du découpage en mesures et en parties de la grille
 \item une barre d'outils pour les actions les plus fréquentes, ainsi que des raccourcis claviers
 \item le rapprochement implicite entre la grille et le morceau (système d'onglets, et fusion des deux anciens éditeurs en un seul)
 \item \dots
\end{itemize}

Le principal défi aura été de faciliter la synchronisation entre le morceau et la grille. Nous avons dans un premier temps mis en place un lecteur audio au sein de l'éditeur afin que l'utilisateur puisse aisément écouter le morceau qu'il est en train de créer. C'est ensuite qu'est venue l'idée d'utiliser trois marqueurs temporels pour définir cette synchronisation:
\begin{enumerate}
 \item Un marqueur pour le premier accord du morceau
 \item Un second marqueur pour signaler la fin de la première mesure
 \item Et un dernier pour signaler la fin du dernier accord du morceau
\end{enumerate}
Une fois les temps associés définis précisément, il est facile de définir le temps de début de chaque accord dans le morceau (voir l'algorithme sur la figure \ref{editor_time_caseitems}). Cette méthode nous a semblé particulièrement adaptée à notre situation, puisque les morceaux ciblés par l'application sont des morceaux qui sont rythmiquement très stables (c'est-à-dire que la durée de chaque mesure est supposée constante). De cette façon, l'utilisateur ne doit que très peu intervenir en comparaison avec l'ancienne méthode qui consistait à lui faire taper chaque temps du morceau.

\begin{figure}[H]
\begin{lstlisting}
for (int r = 0 ; r < rmax ; r++) //Parcours des lignes
{
	for (int c = 0 ; c < cmax - 1 ; c ++) //Parcours des colonnes
	{
		QTime caseTime = MsecToTime(
				    (TimeToMsec(beginning) +
				      ((TimeToMsec(bar) - TimeToMsec(beginning))
				        /m_barsize)
				    * (r * (cmax - 1) + c)));
		((CaseItem*) item(r,c))->setBeginning(caseTime);
	}
}
\end{lstlisting}
\caption{Mise en place des temps de début des accords en fonction des marqueurs entrés par l'utilisateur, extrait de \texttt{ChordTableWidget::setTimeInfo}}
\label{editor_time_caseitems}
\end{figure}

La question était donc de trouver un moyen simple pour pouvoir indiquer de façon précise chacun de ces trois marqueurs temporels. Il nous est tout de suite venu à l'esprit d'utiliser les formes d'ondes du fichier audio désiré pour mieux cibler les débuts des accords. FMOD, pour les données spectrales, et Qt, pour l'interface, ont été très utiles pour l'implémentation. Un zoom a également été mis en place sur cette même forme d'onde, ainsi que le positionnement des timers directement \textit{sur} la forme d'onde. Au final, le marquage devient une tâche relativement aisée et rapide (figure \ref{editor_waveform}).



\subsubsection{Sur le lecteur}

En ce qui concerne le lecteur, nous n'avons dans un premier temps que modifié l'interface. Celle-ci a été refaite intégralement selon la maquette qui avait en janvier (voir la figure \ref{annexe_proto_player} en annexe). Notre travail a finalement abouti à une interface semblable aux exigences qui avaient été fixées, certains détails ayant été revus en cours de développement en accord avec nos clients. L'objectif principal était de rendre le programme beaucoup plus convivial, mais aussi plus accessible. L'interface actuelle est présentée en figure \ref{interface_player}.

Dans un deuxième temps, nous avons fait le choix de revoir le fonctionnement interne du lecteur. Comme évoqué précédemment, nous avons ainsi commencé par remplacer la librairie \textit{libsndfile} par FMOD en vue de supporter de nouveaux formats audio. FMOD se charge en fait d'ouvrir le fichier audio demandé et de le mettre en mémoire. La gestion à proprement parler du son reste la tâche de PortAudio.

C'est ensuite toute la librairie \textit{IScoreLight} que nous avons faite disparaître. En effet, celle-ci comportait plusieurs dizaines de fichiers sources qui, au final, n'étaient pas exploités. Les quelques parties de la librairie qui nous étaient utiles ont donc été reprises et fusionnées au sein de la classe \texttt{SongManager}.

Finalement, il ne reste aujourd'hui de la première version du lecteur que la gestion bas niveau du son, notamment l'analyse des accords effectuée par la librairie \textit{EHPCP}. Ce tri nous a permis d'améliorer grandement les performances, notamment lors de la compilation du programme (cf figure \ref{refonte_code}).

\begin{figure}[H]
\begin{center}
\includegraphics[width=300px]{refonte_code.png}
\caption{Suppression des bibliothèques Boost et IScoreLight du projet}
\label{refonte_code}
\end{center}
\end{figure}

Nous avons également fais en sorte que le lecteur utilise par défaut OpenGL, afin que celui-ci soit, au moins partiellement, exécuté sur la carte graphique de l'utilisateur, en vue d'améliorer là encore les performances.

\subsection{Installateurs sur les différents systèmes d'exploitation}

Comme il nous avait été demandé, le programme devait être rendu sous la forme d'un installateur pour chacun des deux systèmes d'exploitation visés.

\subsubsection{Sur Windows}

Sur Windows, GuitarTutor se présente sous la forme d'un installateur \textit{msi} créé avec le logiciel Advance Installer. L'apparence de cet installateur est tout à fait semblable aux installateurs de logiciels Windows habituels, et propose les mêmes options; comme par exemple la possibilité de modifier le chemin de l'installation, ou encore celle de créer une icône sur le bureau de l'utilisateur.

La seule véritable difficulté sur ce système d'exploitation aura été de définir quelles étaient les librairies dynamiques à inclure dans notre package. Pour cela, nous avons testé sur des machines vierges de tout outil lié à notre environnement de travail (Qt, FMOD,\dots), puis simplement procédé par élimination pour ne retenir que les fichiers dll nécessaires.

\subsubsection{Sur Mac OS X}

Sur Mac OS X, notre programme se présente comme une application \textit{.app}, autrement appelé \textit{bundle}. C'est avec le format \textit{dmg}, sur ce système d'exploitation, une des deux formes les plus usuelles pour distribuer un logiciel. Il s'agit en fait d'un dossier contenant l'exécutable en lui-même, ainsi que tous les éléments tels que les bibliothèques dynamiques nécessaires à son fonctionnement (cf figure \ref{app_mac_os}).

\begin{figure}[H]
\begin{center}
\includegraphics[width=300px]{bundle_mac.png}
\caption{Le bundle pour Mac OS X (d'après qt-project.org)}
\label{app_mac_os}
\end{center}
\end{figure}

Plusieurs outils similaires sont mis à la disposition des développeurs Mac OS X pour créer ces bundles. Nous avons, dans un premier temps, choisi d'utiliser l'utilitaire \textit{qtmacdeployment}, fourni avec Qt. Seulement, il s'est avéré que les bundles créés ne fonctionnaient pas sur toutes les machines en raison d'un problème concernant la bibliothèque dynamique de FMOD. Nous avons finalement opté pour un autre outil, du nom de \textit{install\_name\_tools}, fourni cette fois-ci avec l'environnement XCode, et qui a réglé notre problème de déploiement.

\subsection{Développement agile}

En accord avec les conseils de notre responsable pédagogique, nous avons rapidement opté pour l'utilisation d'une méthode de développement de type agile. Le PFA état en effet une excellente occasion pour s'essayer à ce genre de méthodes qui sont de plus en plus employées dans des cadres professionnels. 

\subsubsection{Réunions clients}

Dès le mois de novembre, nous avons mis en place un système de rendez-vous réguliers, généralement toutes les trois semaines avec nos clients. Ces réunions servaient tout d'abord à présenter le travail qui avait été effectué depuis le dernier rendez-vous, au travers d'une démonstration sur le logiciel en cours de développement. S'en suivait une discussion sur les différents points qui méritaient d'être relevés, afin de répartir les tâches en trois catégories: ce qui était fait et qui était validé, ce qui était fait mais restait à améliorer (ou à changer totalement), et enfin, ce qui restait à faire. Il ne restait alors qu'à fixer les objectifs à tenir d'ici le prochain rendez-vous.

Les avantages de travailler de la sorte se sont révélés au cours du projet. Tout d'abord, la possibilité de discuter de manière régulière de nos avancées avec nos clients était particulièrement intéressante, car cela permet d'instaurer un dialogue entre demandeurs et réalisateurs. On peut notamment remarquer que le cahier des charges (cf annexes) comporte plusieurs points qui n'ont pas été réalisés, ou qui ont été réalisés différemment de ce qui était initialement prévu, pas à cause d'un manque de temps, mais grâce à ce dialogue qui a permis d'affiner et de changer les besoins exprimés au fur et à mesure du développement du projet.

La figure \ref{agile} résume ce processus.

\begin{figure}[H]
\begin{center}
\includegraphics[width=450px]{methode_agile.png}
\caption{Schéma du processus de développement agile}
\label{agile}
\end{center}
\end{figure}

\subsubsection{Organisation de l'équipe et du travail}

De manière analogue au \textit{ScrumMaster} de la méthode Scrum, nous avons choisi au sein de notre équipe une personne en charge de veiller à la bonne application de notre méthode de développement. Sans se situer à un niveau supérieur aux autres, comme ce serait le cas pour un chef de projet, cette personne devait centraliser les travaux et les impressions de chacun pour aider à la répartition des tâches. Elle servait par ailleurs de \textit{représentant} de notre équipe pour nos clients et notre responsable pédagogique.

Les tâches étaient ensuite attribuées selon les demandes du cycle courant et des préférences de chacun, généralement par binômes. Des réunions hebdomadaires permettaient de faire le point sur les difficultés rencontrées et l'avancement des différentes tâches, et éventuellement de réorganiser la répartition. En plus de cela, l'équipe était informée par mail des interrogations et des avancées entre deux réunions, ainsi que par l'intermédiaire de notre wiki que nous avons mis en place dès le début du projet.

De manière générale, cette méthode de développement semble avoir bien fonctionné pour notre équipe au cours de ce projet.

\clearpage

\section*{Conclusion}

\subsection*{Un objectif atteint}

Nos clients avaient été très clair à ce sujet lors de la présentation du projet: l'objectif était, à la fin du PFA, de fournir deux programmes totalement fonctionnels, et prêts pour une démonstration en école de musique.

Nous avons remis à nos clients, peu de temps avant la date finale des projets, une version en \textit{pre-release} de GuitarTutor afin qu'ils puissent avoir un réel aperçu du programme, et que nous puissions, le cas échéant, corriger quelques détails. Ceux-ci semblent avoir été particulièrement satisfaits du travail que nous avons réalisé, et c'est là le plus important pour notre propre satisfaction. Le deuxième point est sans doute le fait que nous pensons clairement avoir atteints les objectifs qui étaient demandés. Nous avons en effet réalisé une suite logicielle qui, à notre sens, semble parfaitement utilisable dans le contexte cible - c'est-à-dire en école de musique -, et c'était d'ailleurs ce vers quoi nous avons orienté notre développement. La compatibilité du projet sur les systèmes Windows et Mac est elle aussi parfaitement respectée, malgré les difficultés loin d'être négligeables auxquelles nous avons été confrontés.

En sus, la reprise de l'ancien code nous a fait comprendre l'importance de produire un code de qualité et de tout faire pour faciliter la reprise ultérieure, éventuellement par des personnes tierces. C'est pourquoi nous avons soigné notre code source en fournissant une documentation exhaustive de notre travail ainsi qu'un code propre et clair (du moins, selon nos critères). Des optimisations ont également été apportées alors qu'elles n'étaient pas explicitement demandées, telles que le nettoyage des librairies inutilisées, la gestion du format MP3, la limitation des fuites mémoires, ou encore l'utilisation d'OpenGL pour améliorer les performances.

\subsection*{Un travail d'équipe, une expérience de travail profesionnel}

Le PFA aura également été l'opportunité d'apprendre à gérer un véritable travail en équipe, d'adopter une méthode de développement, ainsi que de connaître des outils comme Git ou la librairie Qt, qui, sans être incontournables, font de même bonne figure sur un CV. C'était aussi l'occasion de débattre et de rechercher des informations sur la manière d'implémenter les choses; ou encore de travailler à partir d'un code existant.

En clair, il s'agissait de savoir se comporter dans un contexte quasi-professionnel, et c'est sans aucun doute une expérience extrêmement enrichissante.
%Ce que nous a apporté le projet
%Apprentissage de librairies complexes
%Si chacun veut mettre un mot personnel ici...

\clearpage





















\begin{titlepage}
  \begin{center}
    \vspace{8cm}
    \Huge \textbf{Annexes}
  \end{center}
\end{titlepage}

\clearpage

\section*{Cahier des charges}\label{cdc}

\textit{Ce document rédigé par nos soins constitue le cahier des charges qui a été validé par nos clients début janvier 2013.}

\vspace{1cm}

Il a été souligné la nécessité de garder à l'esprit le public visé afin de le cibler au mieux - à savoir les professeurs de guitare d'une école de musique et leurs élèves, ainsi qu'une population de ``joueurs'' désirant s'initier ou s'améliorer à la guitare. L'interface et les fonctionnalités des logiciels du projet devront donc être adaptés en conséquence, en visant à la fois l'accessibilité et l'ergonomie. En outre, lors des entretiens avec les clients, de nombreux points ont été soulevés et soumis à notre évaluation. Nous les détaillerons dans cette partie.

\subsubsection*{Relatifs à l'ensemble du projet}

Les points suivants s'appliquent à l'ensemble du projet, c'est-à-dire à la fois à l'éditeur et au player.
\begin{itemize}
 \item \underline{Deux logiciels :} les parties éditeur et player devront être séparées en deux exécutables
 \begin{itemize}
  \item De cette façon, l'éditeur sera réservé au professeur.
  \item Le player sera quant à lui accessible au professeur et à son élève.
 \end{itemize}
 \item \underline{Mac OS X et Windows :} le projet devra pouvoir être utilisable intégralement sur ces deux systèmes d'exploitation.
 \begin{itemize}
  \item A cet effet, nous reprendrons les bibliothèques Qt, FMOD et Portaudio utilisées dans les précédentes versions du logiciel, et qui ont l'avantage d'être multi-OS.
  \item Le livrable sera fourni sous la forme d'un installateur pour chacun de ces OS.
 \end{itemize}
 \item \underline{Interface :} comme il a été souligné précédemment, un soin particulier sera attaché à l'interface utilisateur pour la rendre la plus intuitive et attrayante possible.
 \begin{itemize}
  \item Pour cela, nous créerons une version traduite en Français
  \item Des menus d'aide seront également présents pour accompagner les utilisateurs
 \end{itemize}
 \item \underline{Version finale :} le logiciel devra être fini et prêt au déploiement dans l'école de musique cliente pour avril 2013.
\end{itemize}

\subsubsection*{Relatifs à l'éditeur}

Les besoins propres à l'éditeur et nos propositions pour y répondre sont énumérés dans cette partie. L'éditeur permettra la saisie des accords d'un morceau par le professeur directement dans une grille.

L'éditeur est destiné à créer une grille d'accords sans assistance. Il se présente sous la forme d'une grille dont chaque case correspond à une mesure, et chaque ligne à une phrase.

\begin{itemize}
 \item \underline{Saisie :} la saisie des accords se fait soit case par case, soit en sélectionnant directement toutes les cases correspondant au même accord.
 \begin{itemize}
  \item Les accords se rentrent soit à la main, soit à l'aide d'un menu listant tous les accords reconnus par le logiciel.
  \item Afin de faciliter la saisie, les derniers accords utilisés seront mis en évidence.
  \item L'utilisateur pourra également indiquer la tonalité du morceau qu'il veut saisir pour que soient mis en évidence les accords les plus utilisés pour cette tonalité.
 \end{itemize}
 \item \underline{Écoute :} pour l'aider lors de la saisie, l'utilisateur pourra écouter directement via l'éditeur le fichier mp3 qu'il aura sélectionné.
 \begin{itemize}
  \item Les fonctionnalités les plus courantes d'un lecteur audio seront implémentées, telles que la pause, la reprise et le retour en arrière.
  \item Il est à noter que cette lecture audio ne servira qu'à l'utilisateur, pas au logiciel. Néanmoins, le chemin vers ce fichier sera retenu afin de pouvoir le réutiliser en changeant de mode d'édition, ou lors de la lecture par le Player de la partition créée.
 \end{itemize}
 \item \underline{Synchronisation audio :} pour que la partition créée soit utilisable par le Player, il faut qu'une information de tempo soit précisée par l'utilisateur.
 \begin{itemize}
  \item Pour cela, l'utilisateur sera invité à ouvrir le fichier mp3 correspondant à sa saisie (s'il ne l'a pas déjà fait pour s'aider lors de cette même saisie).
  \item Une fenêtre l'invitera à démarrer le fichier mp3 et à appuyer deux fois sur la touche espace de son clavier.
  \item Ces deux appuis délimiteront la durée d'une case de la grille.
  \item Si besoin est, il pourra recommencer cette étape à sa guise.
  \item Cette étape est facultative si l'utilisateur ne souhaite pas utiliser sa partition sur le player.
 \end{itemize}
\end{itemize}

\underline{Fonctionnalités générales de l'éditeur}

Afin que l'utilisateur puisse accéder à n'importe quel moment aux partitions qu'il aura créées, il se verra offrir la possibilité d'exporter sa grille d'accords dans un fichier.

\begin{itemize}
 \item \underline{Export :} deux formats de fichiers seront utilisables pour sauvegarder la partition sur le disque dur de l'utilisateur.
 \begin{itemize}
  \item Un premier format dit “grille” adoptera les conventions de l'école de musique cliente et servira pour impression.
  \item Un second format basé sur le langage xml permettra l'utilisation de la partition sur le player. L'étape de synchronisation audio devra être validée au préalable.
  \item Ces deux formats ne sont pas incompatibles, c'est-à-dire que la partition pourra être sauvegardée aussi bien dans un format que dans l'autre, et pourquoi pas dans les deux en même temps.
 \end{itemize}
 \item \underline{Import :} pour permettre d'éditer une partition dont la saisie a déjà été commencée, il sera possible de charger un fichier grille ou xml généré préalablement par l'éditeur. La grille d'accords sera remplie comme il se doit avec les données du fichier.
\end{itemize}

L'interface devra également permettre une plus grande flexibilité que l'actuelle au niveau des morceaux. Il devra par exemple être possible de modifier le nombre de cases par ligne en cours de saisie, ainsi que de générer des partitions aux mesures irrégulières. Dans ce cas, l'export au format grille serait autorisé, mais celui au format xml nécessitera au préalable que l'utilisateur indique tous les changements de mesures ainsi que les durées de chaque case dans ces portions.

\subsubsection*{Relatifs au player}

La partie jouable du projet est déjà fonctionnelle. Il faudra cependant veiller à y apporter quelques nouveautés.

\begin{itemize}
 \item \underline{Deux modes :} un mode orienté jeu et un mode orienté apprentissage
 \begin{itemize}
  \item Le mode jeu se basera sur un score calculé en deux étapes
  \begin{itemize}
   \item A-t-il joué le bon accord?
   \item L'a-t-il tenu assez longtemps?
  \end{itemize}
  \item Le mode apprentissage bouclera sur les différentes parties du morceau jusqu'à ce que le joueur les réussisse parfaitement.
 \end{itemize}
 \item \underline{Interface :} plus attrayante et plus ergonomique
 \begin{itemize}
  \item Proposer un mode plein écran
  \item Indiquer au joueur son avancée dans la partition au cours de la partie
  \item Mode horizontal ou vertical
 \end{itemize}
 \item \underline{Enchaînement :} possibilité de jouer plusieurs morceaux à la suite
 \item \underline{Entrées audio :} gestion des différentes entrées audio de l'ordinateur.
 \begin{itemize}
  \item Une extension intéressante serait de développer un mode multijoueur.
 \end{itemize}
\end{itemize}


\begin{figure}[!ht]
\begin{center}
\includegraphics[width=450px]{interface_player_prototype.jpg}
\caption{Prototype d'interface pour le player}
\label{annexe_proto_player}
\end{center}
\end{figure}


\subsubsection*{API GuitarTutor}

Afin de faciliter la maintenance du code source et l'extension des fonctionnalités, nous axerons nos premières étapes de développement sur la création d'une API commune à l'éditeur et au player dans le but de respecter une architecture Modèle Vue Contrôleur (MVC). Cette méthode de développement n'ayant pas été utilisée par nos prédécesseurs, il nous faudra un certain temps pour reconstruire proprement le projet, mais nous sommes certains que cela sera un gain de temps pour la suite du développement.

\clearpage

\end{document}
